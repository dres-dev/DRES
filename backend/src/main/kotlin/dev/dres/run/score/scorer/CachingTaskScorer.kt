package dev.dres.run.score.scorer

import dev.dres.data.model.submissions.Submission
import dev.dres.data.model.template.team.TeamId
import dev.dres.run.score.Scoreable
import dev.dres.utilities.extensions.convertWriteLock
import dev.dres.utilities.extensions.write
import jetbrains.exodus.kotlin.synchronized
import java.util.*
import java.util.concurrent.locks.StampedLock
import kotlin.collections.HashMap

/**
 * A [TaskScorer] that caches intermediate results for performance gains.
 *
 * @author Luca Rossetto
 * @version 1.0.0
 */
class CachingTaskScorer(private val wrapped: TaskScorer): TaskScorer {

    /** The [Scoreable] held by the wrapped [TaskScorer].  */
    override val scoreable: Scoreable
        get() = this.wrapped.scoreable

    /** Map of the latest scores that has been cached by this [TaskScorer]. */
    private val latest: MutableMap<TeamId, Double> = HashMap()

    /** A flag indicating, that this [CachingTaskScorer] is dirty and must re-calculate its content. */
    @Volatile
    private var dirty = true

    /** */
    private val lock = StampedLock()

    /**
     * Returns a map of [TeamId] to score as generated by this [TaskScorer]. Updates the local cache as a side-effect.
     *
     * @return A [Map] of [TeamId] to score value
     */
    override fun scoreMap(): Map<TeamId, Double> {
        var stamp = this.lock.readLock()
        try {
            if (this.dirty) {
                stamp = this.lock.convertWriteLock(stamp)
                this.latest.putAll(this.wrapped.scoreMap())
                this.dirty = false
            }
            return Collections.unmodifiableMap(this.latest)
        } finally {
            this.lock.unlock(stamp)
        }
    }

    /**
     * Invalidates the content held by this [CachingTaskScorer].
     */
    fun invalidate() = this.lock.write {
        this.dirty = true
    }
}