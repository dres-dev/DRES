package dev.dres.run.score.scorer

import dev.dres.data.model.submissions.Submission
import dev.dres.data.model.template.team.TeamId
import dev.dres.run.score.Scoreable
import dev.dres.utilities.extensions.convertWriteLock
import dev.dres.utilities.extensions.write
import jetbrains.exodus.kotlin.synchronized
import java.util.*
import java.util.concurrent.locks.ReentrantReadWriteLock
import java.util.concurrent.locks.StampedLock
import kotlin.collections.HashMap
import kotlin.concurrent.read
import kotlin.concurrent.write

/**
 * A [TaskScorer] that caches intermediate results for performance gains.
 *
 * @author Luca Rossetto
 * @version 1.0.0
 */
class CachingTaskScorer(private val wrapped: TaskScorer) : TaskScorer {

    /** The [Scoreable] held by the wrapped [TaskScorer].  */
    override val scoreable: Scoreable
        get() = this.wrapped.scoreable

    /** Map of the latest scores that has been cached by this [TaskScorer]. */
    private val latest: MutableMap<TeamId, Double> = HashMap()

    /** A flag indicating, that this [CachingTaskScorer] is dirty and must re-calculate its content. */
    @Volatile
    private var dirty = true

    /** */
    private val lock = ReentrantReadWriteLock()

    /**
     * Returns a map of [TeamId] to score as generated by this [TaskScorer]. Updates the local cache as a side-effect.
     *
     * @return A [Map] of [TeamId] to score value
     */
    override fun scoreMap(): Map<TeamId, Double> = this.lock.read {

        if (this.dirty) {
            this.lock.write {
                this.latest.putAll(this.wrapped.scoreMap())
                this.dirty = false
            }
        }
        return this.latest

    }

    /**
     * Invalidates the content held by this [CachingTaskScorer].
     */
    fun invalidate() = this.lock.write {
        this.dirty = true
    }
}