package dev.dres.run.score.scorer

import dev.dres.data.model.submissions.Submission
import dev.dres.data.model.template.team.TeamId
import dev.dres.run.score.Scoreable

/**
 * A [TaskScorer] that caches intermediate results for performance gains.
 *
 * @author Luca Rossetto
 * @version 1.0.0
 */
class CachingTaskScorer(private val wrapped: TaskScorer): TaskScorer {

    /** The [Scoreable] held by the wrapped [TaskScorer].  */
    override val scoreable: Scoreable
        get() = this.wrapped.scoreable

    /** Map of the latest scores that has been cached by this [TaskScorer]. */
    private var latest: Map<TeamId, Double> = emptyMap()

    /**
     * Returns the cached value of this [TaskScorer]d.
     *
     * @return A [Map] of [TeamId] to calculated task score.
     */
    fun scoreMapFromCache(): Map<TeamId, Double> = this.latest

    /**
     * Returns the cached value of this [TaskScorer].
     *
     * @return A [List] of [ScoreEntry].
     */
    fun scoreListFromCache(): List<ScoreEntry> = this.latest.map { ScoreEntry(it.key, null, it.value) }

    /**
     * Returns a map of [TeamId] to score as generated by this [TaskScorer]. Updates the local cache as as side-effect.
     *
     * @param submissions A [Sequence] of [Submission]s to obtain scores for.
     * @return A [Map] of [TeamId] to score value
     */
    override fun scoreMap(submissions: Sequence<Submission>): Map<TeamId, Double> {
        val map = this.wrapped.scoreMap(submissions)
        this.latest = map
        return map
    }

    /**
     * Returns a list of [ScoreEntry] generated by this [TaskScorer]. Updates the local cache as as side-effect.
     *
     * @param submissions A [Sequence] of [Submission]s to obtain scores for.
     * @return A [Map] of [TeamId] to score value
     */
    override fun scores(submissions: Sequence<Submission>): List<ScoreEntry> {
        val map = this.wrapped.scoreMap(submissions)
        this.latest  = map
        return map.map { ScoreEntry(it.key, null, it.value) }
    }
}